#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../config/environment'
require_relative '../lib/fedora_cache'
require_relative '../lib/data_error_notifier'
require 'set'
require 'optparse'
require 'diffy'
require 'dor/services/client'
require 'equivalent-xml'

options = { random: false, druids: [], fast: false }
parser = OptionParser.new do |option_parser|
  option_parser.banner = 'Usage: bin/validate-cocina-roundtrip [options]'

  option_parser.on('-sSAMPLE', '--sample SAMPLE', Integer, 'Sample size, otherwise all druids.')
  option_parser.on('-r', '--random', 'Select random druids.')
  option_parser.on('-dDRUIDS', '--druids DRUIDS', Array, 'List of druids (instead of druids.txt).')
  option_parser.on('-h', '--help', 'Displays help.') do
    puts option_parser
    exit
  end
end
parser.parse!(into: options)

cache = FedoraCache.new

Dor::Services::Client.configure(url: Settings.dor_services.url,
                                token: Settings.dor_services.token)

def write_result(druid, orig_cocina_hash, roundtrip_cocina_hash, diff_datastreams)
  File.open("results/#{druid}.txt", 'w') do |file|
    file.write("Druid: #{druid}\n\n")

    cocina_keys = (orig_cocina_hash.keys + roundtrip_cocina_hash.keys).uniq
    cocina_keys.each do |cocina_key|
      next if DeepEqual.match?(orig_cocina_hash[cocina_key], roundtrip_cocina_hash[cocina_key])

      file.write("Diff for #{cocina_key}:\n")
      file.write(Diffy::Diff.new("#{JSON.pretty_generate(orig_cocina_hash[cocina_key])}\n", "#{JSON.pretty_generate(roundtrip_cocina_hash[cocina_key])}\n"))
      file.write("\n\n")
    end

    diff_datastreams.each_pair do |dsid, ng_xmls|
      orig_ds_ng_xml, ds_ng_xml = ng_xmls

      file.write("Diff for #{dsid}:\n")
      file.write(Diffy::Diff.new("#{orig_ds_ng_xml.to_xml}\n", "#{ds_ng_xml.to_xml}\n"))
      file.write("\n\n")
    end
  end
end

def write_error(druid, error)
  File.open("results/#{druid}.txt", 'w') do |file|
    file.write("Druid: #{druid}\n\n")
    file.write("Error: #{error}\n\n")
    file.write("Backtrace:\n")
    file.write(error.backtrace.join("\n"))
    if error.cause
      file.write("\n\nCause:\n")
      file.write(error.cause.backtrace.join("\n"))
    end
  end
end

# A little monkeypatching never hurt anyone, right?

# Monkeypatch to retrieve tags using dor-services-client so that does not need to be run on dor-services-app server.
class AdministrativeTags
  def self.project(pid:)
    tag = Dor::Services::Client.object(pid)
                               .administrative_tags
                               .list
                               .find { |check_tag| check_tag.start_with?('Project :') }

    return [] unless tag

    [tag.split(' : ', 2).last]
  end

  def self.content_type(pid:)
    tag = Dor::Services::Client.object(pid)
                               .administrative_tags
                               .list
                               .find { |check_tag| check_tag.start_with?('Process : Content Type :') }

    return [] unless tag

    [tag.split(' : ').last]
  end
end

module ActiveFedora
  # Monkeypatch to avoid hitting Solr.
  class SolrService
    def self.query(query); end
  end
end

module ActiveFedora
  # Monkeypatch to avoid hitting Solr.
  class SolrService
    def self.reify_solr_results(_result)
      []
    end
  end
end

def load_fedora_obj(druid, cache)
  label, datastreams = cache.label_and_datastreams(druid).value!

  obj = fedora_class(datastreams['RELS-EXT']).new(pid: druid, label: label)
  FedoraCache::DATASTREAMS.each do |dsid|
    datastream = datastreams[dsid]
    obj.datastreams[dsid].content = datastream if datastream
  end
  obj.relationships = obj.rels_ext.content
  obj
end

def fedora_class(rels_ext)
  rels_ext_ng_xml = Nokogiri::XML(rels_ext)
  model = rels_ext_ng_xml.root.xpath('//fedora-model:hasModel', 'fedora-model' => 'info:fedora/fedora-system:def/model#').first['rdf:resource']
  case model
  when 'info:fedora/afmodel:Dor_Collection'
    Dor::Collection
  when 'info:fedora/afmodel:Dor_AdminPolicyObject'
    Dor::AdminPolicyObject
  when 'info:fedora/afmodel:Dor_Item'
    Dor::Item
  else
    raise 'Unmapped'
  end
end

def ng_xml_for(xml)
  Nokogiri::XML(xml) { |config| config.default_xml.noblanks }
end

def validate_druid(druid, cache)
  return :missing unless cache.cached?(druid)

  begin
    fedora_obj = load_fedora_obj(druid, cache)
  rescue StandardError => e
    return :unmapped if e.message == 'Unmapped'

    raise
  end

  begin
    orig_cocina_obj = Cocina::Mapper.build(fedora_obj, notifier: DataErrorNotifier.new)
  rescue StandardError => e
    write_error(druid, e)
    return :mapping_error
  end

  orig_cocina_hash = orig_cocina_obj.to_h

  begin
    roundtrip_cocina_obj = Cocina::ObjectUpdater.run(fedora_obj, orig_cocina_obj, trial: true, notifier: DataErrorNotifier.new)
  rescue StandardError => e
    write_error(druid, e)
    return :update_error
  end
  roundtrip_cocina_hash = roundtrip_cocina_obj.to_h

  diff_datastreams = {}
  FedoraCache::DATASTREAMS.each do |dsid|
    result = cache.datastream(druid, dsid)
    next if result.failure?

    orig_ds_ng_xml = ng_xml_for(result.value!)

    ds_ng_xml = ng_xml_for(fedora_obj.datastreams[dsid].content)
    next if EquivalentXml.equivalent?(orig_ds_ng_xml, ds_ng_xml, { element_order: false, normalize_whitespace: false })

    diff_datastreams[dsid] = [orig_ds_ng_xml, ds_ng_xml]
  end

  return :success if DeepEqual.match?(normalize(orig_cocina_hash), roundtrip_cocina_hash)

  # && diff_datastreams.empty?
  # Currently only determining success based on cocina.
  # However, in future might want to also check datastreams. This would require normalization.

  write_result(druid, orig_cocina_hash, roundtrip_cocina_hash, diff_datastreams)
  :different
end

def normalize(cocina_hash)
  # Remove space from source id, e.g., "sul: M0443_S2_D-K_B9_F33_011"
  source_id = cocina_hash.dig(:identification, :sourceId)
  cocina_hash[:identification][:sourceId] = source_id.gsub(/ *: */, ':') if source_id

  cocina_hash
end

def percentage(raw_num, denom)
  (100 * raw_num.to_f / denom).round(3)
end

unless options[:fast]
  FileUtils.rm_rf('results')
  FileUtils.mkdir_p('results')
end

if options[:druids].empty?
  druids = File.read('druids.txt').split
  druids.shuffle! if options[:random]
  druids = druids.take(options[:sample]) if options[:sample]
else
  druids = options[:druids]
end

results = Parallel.map(druids, progress: 'Testing') do |druid|
  validate_druid(druid, cache)
end
counts = { different: 0, success: 0, mapping_error: 0, update_error: 0, missing: 0, unmapped: 0 }
results.each { |result| counts[result] += 1 }

denom = druids.size - counts[:missing] - counts[:unmapped]

puts "Status (n=#{druids.size}; not using Missing for success/different/error stats):"
puts "  Success:   #{counts[:success]} (#{percentage(counts[:success], denom)}%)"
puts "  Different: #{counts[:different]} (#{percentage(counts[:different], denom)}%)"
puts "  Mapping error:     #{counts[:mapping_error]} (#{percentage(counts[:mapping_error], denom)}%)"
puts "  Update error:     #{counts[:update_error]} (#{percentage(counts[:update_error], denom)}%)"
puts "  Missing:     #{counts[:missing]} (#{(100 * counts[:missing].to_f / druids.size).round(3)}%)"
puts "  Unmapped:     #{counts[:unmapped]} (#{(100 * counts[:unmapped].to_f / druids.size).round(3)}%)"
