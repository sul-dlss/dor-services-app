#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../config/environment'
require_relative '../lib/fedora_cache'
require 'set'
require 'optparse'
require 'diffy'

options = { random: false, druids: [] }
parser = OptionParser.new do |option_parser|
  option_parser.banner = 'Usage: bin/validate-cocina-roundtrip [options]'

  option_parser.on('-sSAMPLE', '--sample SAMPLE', Integer, 'Sample size, otherwise all druids.')
  option_parser.on('-r', '--random', 'Select random druids.')
  option_parser.on('-dDRUIDS', '--druids DRUIDS', Array, 'List of druids (instead of druids.txt).')
  option_parser.on('-h', '--help', 'Displays help.') do
    puts option_parser
    exit
  end
end
parser.parse!(into: options)

cache = FedoraCache.new

def round_tripped_ng_xml(cocina, druid)
  Nokogiri::XML(Cocina::ToFedora::Descriptive.transform(cocina, druid).to_xml) { |config| config.default_xml.noblanks }
end

def cocina_model(ng_xml, label)
  title_builder = Cocina::FromFedora::Descriptive::TitleBuilderStrategy.find(label: label)
  desc_props = Cocina::FromFedora::Descriptive.props(title_builder: title_builder, mods: ng_xml)
  Cocina::Models::Description.new(desc_props)
end

def write_result(druid, original_ng_xml, roundtrip_ng_xml, cocina, differences)
  File.open("results/#{druid}.txt", 'w') do |file|
    file.write("Druid: #{druid}\n\n")

    differences.each_with_index do |difference, index|
      file.write("Differences #{index + 1}\n")
      file.write("Original node:\n#{difference.mods_node1}\n")
      if difference.mods_node2
        file.write("Best guess roundtripped node:\n#{difference.mods_node2}\n")
        file.write("Difference:\n#{Diffy::Diff.new("#{difference.mods_node1}\n", "#{difference.mods_node2}\n")}\n")
      else
        file.write("Could not find similar roundtripped node.\n")
      end
    end

    file.write("\nOriginal XML:\n#{original_ng_xml.to_xml}\n")
    file.write("Roundtripped XML:\n#{roundtrip_ng_xml.to_xml}\n")
    file.write("Cocina:\n#{JSON.pretty_generate(cocina.to_h)}\n\n")
  end
end

def write_error(druid, original_ng_xml, cocina, error)
  File.open("results/#{druid}.txt", 'w') do |file|
    file.write("Druid: #{druid}\n\n")
    file.write("Error: #{error}\n\n")
    file.write("Expected XML:\n#{original_ng_xml.to_xml}\n\n")
    file.write("Cocina:\n#{JSON.pretty_generate(cocina.to_h)}\n\n")
    file.write("Backtrace:\n")
    file.write(error.backtrace.join("\n"))
  end
end

def validate_druid(druid, cache)
  begin
    original_ng_xml = cache.descmd_xml(druid)
    label = cache.label(druid)
  rescue StandardError
    return :missing
  end

  begin
    cocina = cocina_model(original_ng_xml, label)
  rescue StandardError
    return :to_cocina_error
  end

  # Changes to support better matching.
  norm_original_ng_xml = Cocina::ModsNormalizer.normalize(original_ng_xml)

  begin
    roundtrip_ng_xml = round_tripped_ng_xml(cocina, druid)
  rescue StandardError => e
    write_error(druid, original_ng_xml, cocina, e)
    return :to_fedora_error
  end

  equiv = ModsEquivalentService.equivalent?(norm_original_ng_xml, roundtrip_ng_xml)

  return :success if equiv.success?

  write_result(druid, norm_original_ng_xml, roundtrip_ng_xml, cocina, equiv.failure)
  :different
end

FileUtils.rm_rf('results')
FileUtils.mkdir_p('results')

if options[:druids].empty?
  druids = File.read('druids.txt').split
  druids.shuffle! if options[:random]
  druids = druids.take(options[:sample]) if options[:sample]
else
  druids = options[:druids]
end

results = Parallel.map(druids, progress: 'Testing') do |druid|
  validate_druid(druid, cache)
end
counts = { different: 0, success: 0, to_cocina_error: 0, to_fedora_error: 0, missing: 0 }
results.each { |result| counts[result] += 1 }

puts "Status (n=#{druids.size}):"
puts "  Success:   #{counts[:success]} (#{100 * counts[:success].to_f / druids.size}%)"
puts "  Different: #{counts[:different]} (#{100 * counts[:different].to_f / druids.size}%)"
puts "  To Cocina error:     #{counts[:to_cocina_error]} (#{100 * counts[:to_cocina_error].to_f / druids.size}%)"
puts "  To Fedora error:     #{counts[:to_fedora_error]} (#{100 * counts[:to_fedora_error].to_f / druids.size}%)"
puts "  Missing:     #{counts[:missing]} (#{100 * counts[:missing].to_f / druids.size}%)"
