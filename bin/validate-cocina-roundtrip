#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../config/environment'
require_relative '../lib/fedora_cache'
require 'set'
require 'optparse'

options = { random: false, druids: [] }
parser = OptionParser.new do |option_parser|
  option_parser.banner = 'Usage: bin/validate-cocina-roundtrip [options]'

  option_parser.on('-sSAMPLE', '--sample SAMPLE', Integer, 'Sample size, otherwise all druids.')
  option_parser.on('-r', '--random', 'Select random druids.')
  option_parser.on('-dDRUIDS', '--druids DRUIDS', Array, 'List of druids (instead of druids.txt).')
  option_parser.on('-h', '--help', 'Displays help.') do
    puts option_parser
    exit
  end
end
parser.parse!(into: options)

cache = FedoraCache.new

# Changes to the original XML to help with matching.
def normalize_original(ng_xml)
  normalize_version(ng_xml)
  normalize_topics(ng_xml)
  normalize_subject_name(ng_xml)
  normalize_authority_uris(ng_xml)
  normalize_subject_authority(ng_xml)
  ng_xml
end

def normalize_version(ng_xml)
  # Only normalize version when version isn't mapped.
  unless /MODS version (\d\.\d)/.match(ng_xml.root.at('//mods:recordInfo/mods:recordOrigin',
                                                      mods: Cocina::FromFedora::Descriptive::DESC_METADATA_NS)&.content)
    ng_xml.root['version'] = '3.6'
    ng_xml.root['xsi:schemaLocation'] = 'http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-6.xsd'
  end
end

def normalize_topics(ng_xml)
  ng_xml.root.xpath('mods:subject[count(mods:topic) = 1]', mods: Cocina::FromFedora::Descriptive::DESC_METADATA_NS).each do |subject_node|
    topic_node = subject_node.xpath('mods:topic', mods: Cocina::FromFedora::Descriptive::DESC_METADATA_NS).first
    normalize_subject(subject_node, topic_node)
  end
end

def normalize_authority_uris(ng_xml)
  ng_xml.root.xpath("mods:*[@authorityURI='http://id.loc.gov/authorities/names']", mods: Cocina::FromFedora::Descriptive::DESC_METADATA_NS).each do |node|
    node[:authorityURI] = 'http://id.loc.gov/authorities/names/'
  end
  ng_xml.root.xpath("mods:*[@authorityURI='http://id.loc.gov/authorities/subjects']", mods: Cocina::FromFedora::Descriptive::DESC_METADATA_NS).each do |node|
    node[:authorityURI] = 'http://id.loc.gov/authorities/subjects/'
  end
end

def normalize_subject_name(ng_xml)
  ng_xml.root.xpath('mods:subject[count(mods:name) = 1]', mods: Cocina::FromFedora::Descriptive::DESC_METADATA_NS).each do |subject_node|
    name_node = subject_node.xpath('mods:name', mods: Cocina::FromFedora::Descriptive::DESC_METADATA_NS).first
    normalize_subject(subject_node, name_node)
  end
end

def normalize_subject(subject_node, child_node)
  return unless subject_node[:authorityURI] || subject_node[:valueURI]

  # If subject has authority and child doesn't, copy to child.
  child_node[:authority] = subject_node[:authority] if subject_node[:authority] && !child_node[:authority]
  # If subject has authorityURI and child doesn't, move to child.
  child_node[:authorityURI] = subject_node[:authorityURI] if subject_node[:authorityURI] && !child_node[:authorityURI]
  subject_node.delete('authorityURI')
  # If subject has valueURI and child doesn't, move to child.
  child_node[:valueURI] = subject_node[:valueURI] if subject_node[:valueURI] && !child_node[:valueURI]
  subject_node.delete('valueURI')
end

def normalize_subject_authority(ng_xml)
  ng_xml.root.xpath("mods:subject[@authority='naf']", mods: Cocina::FromFedora::Descriptive::DESC_METADATA_NS).each do |subject_node|
    subject_node[:authority] = 'lcsh'
  end
end

def round_tripped_ng_xml(cocina, druid)
  Nokogiri::XML(Cocina::ToFedora::Descriptive.transform(cocina, druid).to_xml)
end

def cocina_model(ng_xml, label)
  title_builder = Cocina::FromFedora::Descriptive::TitleBuilderStrategy.find(label: label)
  desc_props = Cocina::FromFedora::Descriptive.props(title_builder: title_builder, mods: ng_xml)
  Cocina::Models::Description.new(desc_props)
end

# rubocop:disable Metrics/ParameterLists
def write_result(druid, original_ng_xml, roundtrip_ng_xml, cocina, error_nodes, unmatched_original_nodes, unmatched_roundtrip_nodes)
  File.open("results/#{druid}.txt", 'w') do |file|
    file.write("Druid: #{druid}\n")
    file.write("Original XML:\n#{original_ng_xml.to_xml}\n")
    file.write("Roundtripped XML:\n#{roundtrip_ng_xml.to_xml}\n")
    file.write("Cocina:\n#{JSON.pretty_generate(cocina.to_h)}\n\n")

    error_nodes.each do |node_pair|
      roundtrip_node = node_pair[0]
      original_node = node_pair[1]

      write_count_mismatch(file, original_node, roundtrip_node) if original_node.element? && original_node.elements.length != roundtrip_node.elements.length
    end

    unmatched_original_nodes.each { |node| file.write("Unmatched original:\n#{node}\n") }
    unmatched_roundtrip_nodes.each { |node| file.write("Unmatched roundtripped:\n#{node}\n") }
  end
end
# rubocop:enable Metrics/ParameterLists

def write_count_mismatch(file, original_node, roundtrip_node)
  file.write("Element count mismatch between original and roundtripped.\n")
  file.write("Original node:\n#{original_node}\n")
  file.write("Roundtripped node:\n#{roundtrip_node}\n\n")
  write_missing(file, original_node, roundtrip_node, 'Missing from roundtripped or unmatched in roundtripped')
  write_missing(file, roundtrip_node, original_node, 'Extra or unmatched in roundtripped')
  file.write("\n")
end

def write_missing(file, node1, node2, label)
  missing_nodes = diff_nodeset(node1.elements, node2.elements)
  return if missing_nodes.empty?

  missing_nodes.each do |node|
    file.write("#{label}:\n")
    file.write("#{node}\n")
    possible_matches = possible_matches_for(node, node2.elements)
    unless possible_matches.empty?
      file.write("Possible match:\n")
      possible_matches.each { |possible_node| file.write("#{possible_node}\n") }
    end
    file.write("\n")
  end
end

def write_error(druid, original_ng_xml, cocina, error)
  File.open("results/#{druid}.txt", 'w') do |file|
    file.write("Error: #{error}\n\n")
    file.write("Expected XML:\n#{original_ng_xml.to_xml}\n\n")
    file.write("Cocina:\n#{JSON.pretty_generate(cocina.to_h)}\n\n")
    file.write("Backtrace:\n")
    file.write(error.backtrace.join("\n"))
  end
end

def diff_nodeset(nodeset1, nodeset2)
  matched_nodeset1 = Set.new
  nodeset1.each do |node1|
    nodeset2.each do |node2|
      matched_nodeset1 << node1 if EquivalentXml.equivalent?(node1, node2)
    end
  end
  Set.new(nodeset1) - matched_nodeset1
end

def possible_matches_for(node, nodeset)
  nodeset.select { |check_node| node.name == check_node.name }
end

def check_equivalent(roundtrip_ng_xml, original_ng_xml)
  all_original_nodes = Set.new
  matched_original_nodes = Set.new
  all_roundtrip_nodes = Set.new
  matched_roundtrip_nodes = Set.new
  error_nodes = []

  equiv = EquivalentXml.equivalent?(roundtrip_ng_xml, original_ng_xml) do |roundtrip_node, original_node, equivalent|
    all_original_nodes << original_node unless original_node.xml?
    all_roundtrip_nodes << roundtrip_node unless roundtrip_node.xml?
    if equivalent
      matched_original_nodes << original_node
      matched_roundtrip_nodes << roundtrip_node
      nil
    elsif original_node.xml?
      nil
    elsif original_node.element? && original_node.name == roundtrip_node.name && original_node.elements.length != roundtrip_node.elements.length
      matched_original_nodes << original_node
      original_node.ancestors.each { |node| matched_original_nodes << node }
      matched_roundtrip_nodes << roundtrip_node
      roundtrip_node.ancestors.each { |node| matched_roundtrip_nodes << node }

      error_nodes << [roundtrip_node, original_node]
      nil
    end
  end
  [equiv, error_nodes, all_original_nodes - matched_original_nodes, all_roundtrip_nodes - matched_roundtrip_nodes]
end

def validate_druid(druid, cache)
  begin
    original_ng_xml = cache.descmd_xml(druid)
    label = cache.label(druid)
  rescue StandardError
    return :missing
  end

  begin
    cocina = cocina_model(original_ng_xml, label)
  rescue StandardError
    return :to_cocina_error
  end

  # Changes to support better matching.
  normalize_original(original_ng_xml)

  begin
    roundtrip_ng_xml = round_tripped_ng_xml(cocina, druid)
  rescue StandardError => e
    write_error(druid, original_ng_xml, cocina, e)
    return :to_fedora_error
  end

  equiv, error_nodes, unmatched_original_nodes, unmatched_roundtrip_nodes = check_equivalent(roundtrip_ng_xml, original_ng_xml)

  unless equiv
    write_result(druid, original_ng_xml, roundtrip_ng_xml, cocina, error_nodes, unmatched_original_nodes, unmatched_roundtrip_nodes)
    return :different
  end
  :success
end

FileUtils.rm_rf('results')
FileUtils.mkdir_p('results')

if options[:druids].empty?
  druids = File.read('druids.txt').split
  druids.shuffle! if options[:random]
  druids = druids.take(options[:sample]) if options[:sample]
else
  druids = options[:druids]
end

results = Parallel.map(druids, progress: 'Testing') do |druid|
  validate_druid(druid, cache)
end
counts = { different: 0, success: 0, to_cocina_error: 0, to_fedora_error: 0, missing: 0 }
results.each { |result| counts[result] += 1 }

puts "Status (n=#{druids.size}):"
puts "  Success:   #{counts[:success]} (#{100 * counts[:success].to_f / druids.size}%)"
puts "  Different: #{counts[:different]} (#{100 * counts[:different].to_f / druids.size}%)"
puts "  To Cocina error:     #{counts[:to_cocina_error]} (#{100 * counts[:to_cocina_error].to_f / druids.size}%)"
puts "  To Fedora error:     #{counts[:to_fedora_error]} (#{100 * counts[:to_fedora_error].to_f / druids.size}%)"
puts "  Missing:     #{counts[:missing]} (#{100 * counts[:missing].to_f / druids.size}%)"
