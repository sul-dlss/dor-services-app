#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../config/environment'
require_relative '../lib/fedora_cache'

if ARGV.length != 1
  puts 'Usage: bin/validate-to-cocina <SAMPLE_SIZE>'
  exit(false)
end

@sample_size = Integer(ARGV[0])

cache = FedoraCache.new

def aggregated_errors_for(results_by)
  aggregated_error_results = results_by.to_a
  aggregated_error_results.sort_by! { |result| result[1].size }
  aggregated_error_results.reverse
end

def results_by(results)
  results_by = {}
  results.each do |result|
    results_by[result.msg] = [] unless results_by.key?(result.msg)
    results_by[result.msg] << result.druid
  end
  results_by
end

def print_results(aggregated_error_results, label)
  aggregated_error_results.each do |error_result|
    puts "#{label}: #{error_result[0]} (#{error_result[1].size} errors)\n"
    puts "Examples: #{error_result[1].take(10).join(', ')}"
  end
end

def write_results(file, aggregated_error_results, label)
  aggregated_error_results.each do |error_result|
    file.write("#{label}: #{error_result[0]} (#{error_result[1].size} errors)\n")
    error_result[1].each { |druid| file.write("#{druid}\n") }
  end
end

def summary_line_for(results, label)
  "#{label}: #{results.size} of #{@sample_size} (#{100 * results.size.to_f / @sample_size}%)"
end

druids = File.read('druids.txt').split

Result = Struct.new(:druid, :msg, :is_data_error)

results = Parallel.map(druids.take(@sample_size), in_processes: 4, progress: 'Testing') do |druid|
  title_builder = Cocina::FromFedora::Descriptive::TitleBuilderStrategy.find(label: cache.label(druid))
  desc_props = Cocina::FromFedora::Descriptive.props(title_builder: title_builder, mods: cache.descmd_xml(druid))
  Cocina::Models::Description.new(desc_props)
  nil
rescue Cocina::Mapper::DataError => e
  Result.new(druid, e.message, true)
rescue StandardError => e
  if e.message == 'Missing item'
    nil
  else
    Result.new(druid, e.message.gsub('\n', ' '), false)
  end
end.compact

error_results = results.reject(&:is_data_error)
data_error_results = results.select(&:is_data_error)

results_by_error = results_by(error_results)
results_by_data_error = results_by(data_error_results)

aggregated_error_results = aggregated_errors_for(results_by_error)
aggregated_data_error_results = aggregated_errors_for(results_by_data_error)

puts "\n#{summary_line_for(error_results, 'Error')}%)\n"
puts "#{summary_line_for(data_error_results, 'Data error')}%)\n"

print_results(aggregated_error_results, 'Error')
print_results(aggregated_data_error_results, 'Data error')

File.open('results.txt', 'w') do |file|
  file.write("#{summary_line_for(error_results, 'Error')}\n")
  file.write("#{summary_line_for(data_error_results, 'Data error')}\n\n")
  write_results(file, aggregated_error_results, 'Error')
  write_results(file, aggregated_data_error_results, 'Data error')
end
