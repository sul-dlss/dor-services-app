#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../config/environment'
require_relative '../lib/fedora_cache'

if ARGV.length != 1
  puts 'Usage: bin/validate-to-cocina <SAMPLE_SIZE>'
  exit(false)
end

sample_size = Integer(ARGV[0])

cache = FedoraCache.new

ignore_errors = ['Cocina::Mapper::MissingTitle', 'Missing item']

druids = File.read('druids.txt').split

results = Parallel.map_with_index(druids.take(sample_size), in_processes: 4) do |druid, index|
  puts "#{druid} (#{index + 1})\n"
  title_builder = Cocina::FromFedora::Descriptive::TitleBuilderStrategy.find(label: cache.label(druid))
  desc_props = Cocina::FromFedora::Descriptive.props(title_builder: title_builder, mods: cache.descmd_xml(druid))
  Cocina::Models::Description.new(desc_props)
  nil
rescue StandardError => e
  if ignore_errors.include?(e.message)
    puts " ignoring. #{e.message}\n\n"
    nil
  else
    puts " error. #{e.message}\n\n"
    [e.message, druid]
  end
end.compact

results_by_error = {}
results.each do |result|
  error = result[0]
  druid = result[1]
  results_by_error[error] = [] unless results_by_error.key?(error)
  results_by_error[error] << druid
end

aggregated_error_results = results_by_error.to_a
aggregated_error_results.sort_by! { |result| result[1].size }
aggregated_error_results.reverse!

error_count = results.size

summary_line = "#{error_count} of #{sample_size} (#{100 * error_count.to_f / sample_size}%)"

puts "\n#{summary_line}%)\n"

aggregated_error_results.each do |error_result|
  puts "Error: #{error_result[0]} (#{error_result[1].size} errors)\n"
  puts "Examples: #{error_result[1].take(10).join(', ')}"
end

File.open('results.txt', 'w') do |file|
  file.write("#{summary_line}\n")
  aggregated_error_results.each do |error_result|
    file.write("Error: #{error_result[0]} (#{error_result[1].size} errors)\n")
    error_result[1].each { |druid| file.write("#{druid}\n") }
  end
end
