#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../config/environment'
require_relative '../lib/fedora_cache'
require 'optparse'

MODS_NS = Cocina::FromFedora::Descriptive::DESC_METADATA_NS

def has_part?(ng_xml)
  ng_xml.root.xpath('//mods:part', mods: MODS_NS).present?
end

def has_xlink_href?(ng_xml)
  ng_xml.xpath('//mods:*[@xlink:href]', mods: MODS_NS, xlink: 'http://www.w3.org/1999/xlink').present?
end

REPORTS = {
  parts: method(:has_part?),
  xlink_href: method(:has_xlink_href?)
}.with_indifferent_access

options = { local: false, reports: REPORTS.keys }
parser = OptionParser.new do |option_parser|
  option_parser.banner = 'Usage: bin/report [options]'
  option_parser.on('-sSAMPLE', '--sample SAMPLE', Integer, 'Sample size, otherwise all druids.')
  option_parser.on('-l', '--local', 'Run locally, i.e., without getting additional metadata from Fedora.')
  option_parser.on('-rREPORTS', '--reports REPORTS', Array, "List of reports to run: #{REPORTS.keys.join(', ')}")
  option_parser.on('-h', '--help', 'Displays help.') do
    puts option_parser
    exit
  end
end
parser.parse!(into: options)

cache = FedoraCache.new

druids = File.read('druids.txt').split
druids = druids.take(options[:sample]) if options[:sample]
@sample_size = druids.size

Result = Struct.new(:druid, :apo, :collections, :catkey, :reports)

run_reports = options[:reports].select { |name| REPORTS.keys.include?(name) }
results = Parallel.map(druids, progress: 'Testing') do |druid|
  ng_xml = cache.descmd_xml(druid)
  reports = []
  run_reports.each do |name|
    reports << name if REPORTS[name].call(ng_xml)
  end
  if reports.empty?
    nil
  elsif options[:local]
    Result.new(druid, nil, nil, nil, reports)
  else
    item = Dor.find(druid)
    Result.new(druid, item.admin_policy_object_id, item.collections.map(&:pid), item.catkey, reports)
  end
rescue Errno::EBUSY
  retry
rescue StandardError => e
  raise if e.message != 'Missing item'

  nil
end.compact

run_reports.each do |name|
  CSV.open("#{name}.csv", 'w') do |writer|
    writer << %w[druid apo collections catkey]
    results.each do |result|
      writer << [result.druid, result.apo, result.collections&.join(', '), result.catkey] if result.reports.include?(name)
    end
  end
end
