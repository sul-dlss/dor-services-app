#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../config/environment'
require_relative '../lib/fedora_cache'
require 'optparse'
require 'set'

MODS_NS = Cocina::FromFedora::Descriptive::DESC_METADATA_NS

def has_part?(ng_xml)
  ng_xml.root.xpath('//mods:part', mods: MODS_NS).present?
end

def has_xlink_href?(ng_xml)
  ng_xml.xpath('//mods:*[@xlink:href]', mods: MODS_NS, xlink: 'http://www.w3.org/1999/xlink').present?
end

def has_frequency?(ng_xml)
  ng_xml.root.xpath('mods:frequency', mods: MODS_NS).present?
end

def bad_event_type?(ng_xml)
  ng_xml.root.xpath('mods:originInfo[@eventType = "Production" or @eventType = "publisher"]', mods: MODS_NS).present?
end

def elements_with_bad_value_uri(ng_xml)
  bad_elements = ng_xml.root.xpath('mods:*[@valueURI and not(starts-with(@valueURI, "http"))]', mods: MODS_NS)
  return false if bad_elements.empty?

  bad_elements.map(&:name).uniq.join(', ')
end

def metadata_toolkit?(ng_xml)
  ng_xml.root.xpath('//mods:recordContentSource[contains(text(), "Metadata ToolKit")]', mods: MODS_NS).present?
end

def elements_start_with_spaces?(ng_xml)
  bad_elements = ng_xml.root.xpath('//mods:*[name() != "mods:identifier" and not(*) and text() and (starts-with(text(), " "))]', mods: MODS_NS)
  return false if bad_elements.empty?

  bad_elements.map(&:to_s).join('; ')
end

def attributes_start_with_spaces?(ng_xml)
  bad_elements = ng_xml.root.xpath('//*[(starts-with(@*, " "))]')
  return false if bad_elements.empty?

  bad_elements.map(&:to_s).join('; ')
end

# rubocop:disable Layout/LineLength
MODS_ELEMENTS = %w[abstract accessCondition affiliation alternativeName area caption cartographicExtension cartographics city citySection classification continent coordinates copyInformation copyrightDate country county date dateCaptured dateCreated dateIssued dateModified dateOther dateValid description descriptionStandard detail digitalOrigin displayForm edition electronicLocator end enumerationAndChronology etal extension extent extraTerrestrialArea form frequency genre geographic geographicCode hierarchicalGeographic holdingExternal holdingSimple identifier internetMediaType island issuance itemIdentifier language languageOfCataloging languageTerm list location mods modsCollection name nameIdentifier namePart nonSort note number occupation originInfo part partName partNumber physicalDescription physicalLocation place placeTerm projection province publisher recordChangeDate recordContentSource recordCreationDate recordIdentifier recordInfo recordInfoNote recordOrigin reformattingQuality region relatedItem role roleTerm scale scriptTerm shelfLocator start state subLocation subTitle subject tableOfContents targetAudience temporal territory text title titleInfo topic total typeOfResource url].freeze
# rubocop:enable Layout/LineLength

def check_elements(ng_xml)
  bad_elements = Set.new
  ng_xml.xpath('//mods:*', mods: MODS_NS).each do |element|
    bad_elements << element.name if MODS_ELEMENTS.exclude?(element.name)
  end
  bad_elements.present? ? bad_elements.to_a.join(', ') : false
end

# rubocop:disable Layout/LineLength
MODS_ATTRS = %w[ID access altFormat altRepGroup altType areaType authority authorityURI calendar citySectionType collection contentType dateLastAccessed displayLabel edition encoding eventType generator invalid keyDate lang level manuscript nameTitleGroup note objectPart order otherType otherTypeAuth otherTypeAuthURI otherTypeURI period point qualifier regionType script shareable source supplied transliteration type typeURI unit unitType usage valueURI version].freeze
# rubocop:enable Layout/LineLength

def check_attrs(ng_xml)
  bad_attrs = Set.new
  ng_xml.xpath('//@*').each do |attr|
    # Namespace is nil for MODS
    bad_attrs << attr.name if MODS_ATTRS.exclude?(attr.name) && attr.namespace.nil?
  end
  bad_attrs.present? ? bad_attrs.to_a.join(', ') : false
end

def date_other(ng_xml)
  date_other_types = Set.new
  ng_xml.root.xpath('mods:originInfo/mods:dateOther', mods: MODS_NS).each do |element|
    date_other_types << "#{element['type'] || 'NONE'} - #{element.parent['eventType'] || 'NONE'}"
  end
  return false if date_other_types.empty?

  date_other_types.to_a.join(', ')
end

REPORTS = {
  parts: method(:has_part?),
  xlink_href: method(:has_xlink_href?),
  mods_elements: method(:check_elements),
  mods_attrs: method(:check_attrs),
  date_other: method(:date_other),
  frequency: method(:has_frequency?),
  bad_event_type: method(:bad_event_type?),
  bad_value_uri: method(:elements_with_bad_value_uri),
  metadata_toolkit: method(:metadata_toolkit?),
  element_spaces: method(:elements_start_with_spaces?),
  attribute_spaces: method(:attributes_start_with_spaces?)
}.with_indifferent_access

options = { local: false, reports: REPORTS.keys }
parser = OptionParser.new do |option_parser|
  option_parser.banner = 'Usage: bin/report [options]'
  option_parser.on('-sSAMPLE', '--sample SAMPLE', Integer, 'Sample size, otherwise all druids.')
  option_parser.on('-l', '--local', 'Run locally, i.e., without getting additional metadata from Fedora.')
  option_parser.on('-rREPORTS', '--reports REPORTS', Array, "List of reports to run: #{REPORTS.keys.join(', ')}")
  option_parser.on('-h', '--help', 'Displays help.') do
    puts option_parser
    exit
  end
end
parser.parse!(into: options)

cache = FedoraCache.new

druids = File.read('druids.txt').split
druids = druids.take(options[:sample]) if options[:sample]
@sample_size = druids.size

Result = Struct.new(:druid, :apo, :collections, :catkey, :reports)

run_reports = options[:reports].select { |name| REPORTS.keys.include?(name) }
results = Parallel.map(druids, progress: 'Testing') do |druid|
  ng_xml = cache.descmd_xml(druid)
  report_results = {}
  run_reports.each do |name|
    report_result = REPORTS[name].call(ng_xml)
    report_results[name] = report_result if report_result
  end
  if report_results.empty?
    nil
  elsif options[:local]
    Result.new(druid, nil, nil, nil, report_results)
  else
    item = Dor.find(druid)
    Result.new(druid, item.admin_policy_object_id, item.collections.map(&:pid), item.catkey, report_results)
  end
rescue Errno::EBUSY
  retry
rescue ActiveFedora::ObjectNotFoundError
  # noop
rescue StandardError => e
  raise if e.message != 'Missing item'

  nil
end.compact

run_reports.each do |name|
  CSV.open("#{name}.csv", 'w') do |writer|
    writer << %w[druid apo collections catkey message]
    results.each do |result|
      next unless result.reports.keys.include?(name)

      writer << [result.druid,
                 result.apo,
                 result.collections&.join(', '),
                 result.catkey,
                 result.reports[name].is_a?(String) ? result.reports[name] : nil]
    end
  end
end
