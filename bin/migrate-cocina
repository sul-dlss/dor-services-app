#!/usr/bin/env ruby
# frozen_string_literal: true

# Migrates cocina objects.
# Migration is performed by a Migrator class that is provided as an argument.
# The Migrator class should be a subclass of or otherwise implement the interface
# of Migrators::Base.
# The migration is run by the Migrators::MigrationRunner class. It uses the migrator
# class to get a list of druids to migrate, and then it uses the migrator class to migrate
# each individual RepositoryObject from that druid list.
# MigrationRunner has the generic mechanisms for actions like committing changes to migrated
# objects, versioning them, and publishing them. _Whether_ each of those actions
# should happen for a given RepositoryObject is determined by the mode in which MigrationRunner
# is invoked (see class for allowable modes) and the various boolean methods on the migrator object (e.g.
# #version? and #publish?).

require_relative '../config/environment'
require 'optparse'
require 'tty-progressbar'

options = { processes: 4, mode: Migrators::MigrationRunner::DEFAULT_MODE, sample: nil }

parser = OptionParser.new do |option_parser|
  option_parser.banner = 'Usage: bin/migrate-cocina MIGRATION_CLASS [options]'
  option_parser.on('--mode [MODE]', Migrators::MigrationRunner::MODES,
                   "Migration mode (#{Migrators::MigrationRunner::MODES.map(&:to_s).join(', ')}). Default is #{Migrators::MigrationRunner::DEFAULT_MODE}")
  option_parser.on('-pPROCESSES', '--processes PROCESSES', Integer,
                   "Number of processes. Default is #{options[:processes]}.")
  option_parser.on('-sSAMPLE', '--sample SAMPLE', Integer, 'Sample size per type, otherwise all objects.')
  option_parser.on('-h', '--help', 'Displays help.') do
    additional_hint = 'See comments in this script, Migrators::MigrationRunner, Migrators::Base, and ' \
                      'Migrators::Exemplar for more details about migrator implementation and migrator modes.'
    puts "#{option_parser}\n\n**#{additional_hint}**"
    exit
  end
end

if ARGV.empty?
  puts 'You must provide a migration class'
  puts parser
  exit
end

parser.parse!(into: options)
migrator_class = ARGV.shift

# how many druids to process as a single advance unit of the progress bar
def num_for_progress_advance(count)
  return 1 if count < 100

  count / 100
end

def on_finish(results, progress_bar)
  progress_bar.advance(results.size)
end

def tty_progress_bar(count, mode)
  TTY::ProgressBar.new(
    "#{mode} [:bar] (:percent (:current/:total), rate: :rate/s, mean rate: :mean_rate/s, :elapsed total, " \
    'ETA: :eta_time)',
    bar_format: :box,
    advance: num_for_progress_advance(count),
    total: count
  )
end

def migrate(migrator_class:, sample:, processes:, mode:)
  druids = Migrators::MigrationRunner.druids_for(migrator_class:, sample:)

  progress_bar = tty_progress_bar(druids.length, mode)
  progress_bar.start

  Parallel.map(druids.each_slice(100),
               in_processes: processes,
               finish: ->(_, _, results) { on_finish(results, progress_bar) }) do |druids_slice|
    Migrators::MigrationRunner.migrate_druid_list(migrator_class:, mode:, druids_slice:).map do |result|
      [result[:obj].id, result[:obj].external_identifier, result[:status]].tap do |r|
        r << result[:exception].message if result[:exception].present?
      end
    end
  end.flatten(1)
end

CSV.open('migrate-cocina.csv', 'w') do |writer|
  writer << %w[id druid result message]
  migrate(migrator_class: migrator_class.constantize, **options)
    .each do |result|
      writer << result
  end
end

exit 0
